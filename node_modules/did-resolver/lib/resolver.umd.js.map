{"version":3,"file":"resolver.umd.js","sources":["../src/resolver.ts"],"sourcesContent":["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Extensible = Record<string, any>\n\nexport interface DIDResolutionResult {\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?: 'invalidDid' | 'notFound' | 'representationNotSupported' | 'unsupportedDidMethod' | string\n}\n\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\nexport type KeyCapabilitySection =\n  | 'authentication'\n  | 'assertionMethod'\n  | 'keyAgreement'\n  | 'capabilityInvocation'\n  | 'capabilityDelegation'\n\nexport type DIDDocument = {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n} & {\n  [x in KeyCapabilitySection]?: (string | VerificationMethod)[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\ninterface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyBase64?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  publicKeyMultibase?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (parsed: ParsedDID, resolve: WrappedResolver) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (did: string, parsed: ParsedDID, resolver: Resolver) => Promise<DIDDocument>\n\nexport interface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true') return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(parsed: ParsedDID, resolve: WrappedResolver): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.%-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(#.*)?`\nconst DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`)\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl,\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {},\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc,\n      }\n    } catch (e) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString(), // This is not in spec, nut may be helpful\n        },\n      }\n    }\n  }\n}\n\nexport type Resolvable = {\n  resolve: (didUrl: string, options?: DIDResolutionOptions) => Promise<DIDResolutionResult>\n}\n\nexport class Resolver implements Resolvable {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(didUrl: string, options: DIDResolutionOptions = {}): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' },\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' },\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n"],"names":["inMemoryCache","cache","Map","parsed","resolve","cached","get","didUrl","undefined","result","didResolutionMetadata","error","set","params","noCache","ID_CHAR","METHOD","METHOD_ID","PARAM_CHAR","PARAM","PARAMS","PATH","QUERY","FRAGMENT","DID_MATCHER","RegExp","parse","sections","match","parts","did","method","id","slice","split","p","kv","path","query","fragment","EMPTY_RESULT","didDocument","didDocumentMetadata","wrapLegacyResolver","resolver","doc","contentType","e","message","toString","Resolver","constructor","registry","options","legacyResolvers","Object","keys","map","methodName"],"mappings":"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"}