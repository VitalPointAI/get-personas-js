"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamUtils = void 0;
const cids_1 = __importDefault(require("cids"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const u8a = __importStar(require("uint8arrays"));
const stream_1 = require("../stream");
const streamid_1 = require("@ceramicnetwork/streamid");
class StreamUtils {
    static streamIdFromState(state) {
        return new streamid_1.StreamID(state.type, state.log[0].cid);
    }
    static serializeCommit(commit) {
        const cloned = lodash_clonedeep_1.default(commit);
        if (StreamUtils.isSignedCommitContainer(cloned)) {
            cloned.jws.link = cloned.jws.link.toString();
            cloned.linkedBlock = u8a.toString(cloned.linkedBlock, 'base64');
            return cloned;
        }
        if (StreamUtils.isSignedCommit(commit)) {
            cloned.link = cloned.link.toString();
        }
        if (StreamUtils.isAnchorCommit(commit)) {
            cloned.proof = cloned.proof.toString();
        }
        if (cloned.id) {
            cloned.id = cloned.id.toString();
        }
        if (cloned.prev) {
            cloned.prev = cloned.prev.toString();
        }
        return cloned;
    }
    static deserializeCommit(commit) {
        const cloned = lodash_clonedeep_1.default(commit);
        if (StreamUtils.isSignedCommitContainer(cloned)) {
            cloned.jws.link = new cids_1.default(cloned.jws.link);
            cloned.linkedBlock = u8a.fromString(cloned.linkedBlock, 'base64');
            return cloned;
        }
        if (StreamUtils.isSignedCommit(cloned)) {
            cloned.link = new cids_1.default(cloned.link);
        }
        if (StreamUtils.isAnchorCommit(cloned)) {
            cloned.proof = new cids_1.default(cloned.proof);
        }
        if (cloned.id) {
            cloned.id = new cids_1.default(cloned.id);
        }
        if (cloned.prev) {
            cloned.prev = new cids_1.default(cloned.prev);
        }
        return cloned;
    }
    static serializeState(state) {
        const cloned = lodash_clonedeep_1.default(state);
        cloned.log = cloned.log.map((entry) => ({ ...entry, cid: entry.cid.toString() }));
        if (cloned.anchorStatus != null) {
            cloned.anchorStatus = stream_1.AnchorStatus[cloned.anchorStatus];
        }
        if (cloned.anchorScheduledFor != null) {
            cloned.anchorScheduledFor = new Date(cloned.anchorScheduledFor).toISOString();
        }
        if (cloned.anchorProof != null) {
            cloned.anchorProof.txHash = cloned.anchorProof.txHash.toString();
            cloned.anchorProof.root = cloned.anchorProof.root.toString();
        }
        if (cloned.lastAnchored != null) {
            cloned.lastAnchored = cloned.lastAnchored.toString();
        }
        cloned.doctype = streamid_1.StreamType.nameByCode(cloned.type);
        return cloned;
    }
    static deserializeState(state) {
        const cloned = lodash_clonedeep_1.default(state);
        if (cloned.doctype) {
            cloned.type = streamid_1.StreamType.codeByName(cloned.doctype);
            delete cloned.doctype;
        }
        cloned.log = cloned.log.map((entry) => ({ ...entry, cid: new cids_1.default(entry.cid) }));
        if (cloned.anchorProof) {
            cloned.anchorProof.txHash = new cids_1.default(cloned.anchorProof.txHash);
            cloned.anchorProof.root = new cids_1.default(cloned.anchorProof.root);
        }
        let showScheduledFor = true;
        if (cloned.anchorStatus) {
            cloned.anchorStatus = stream_1.AnchorStatus[cloned.anchorStatus];
            showScheduledFor =
                cloned.anchorStatus !== stream_1.AnchorStatus.FAILED && cloned.anchorStatus !== stream_1.AnchorStatus.ANCHORED;
        }
        if (cloned.anchorScheduledFor) {
            if (showScheduledFor) {
                cloned.anchorScheduledFor = Date.parse(cloned.anchorScheduledFor);
            }
            else {
                delete cloned.anchorScheduledFor;
            }
        }
        if (cloned.lastAnchored) {
            cloned.lastAnchored = new cids_1.default(cloned.lastAnchored);
        }
        return cloned;
    }
    static statesEqual(state1, state2) {
        return (JSON.stringify(StreamUtils.serializeState(state1)) ===
            JSON.stringify(StreamUtils.serializeState(state2)));
    }
    static isStateSupersetOf(state, base) {
        if (state.log.length < base.log.length) {
            return false;
        }
        for (const i in base.log) {
            if (!state.log[i].cid.equals(base.log[i].cid)) {
                return false;
            }
        }
        if (state.anchorStatus != base.anchorStatus) {
            return false;
        }
        return true;
    }
    static async convertCommitToSignedCommitContainer(commit, ipfs) {
        if (StreamUtils.isSignedCommit(commit)) {
            const block = await ipfs.block.get(commit.link);
            return {
                jws: commit,
                linkedBlock: block.data,
            };
        }
        return commit;
    }
    static isSignedCommitContainer(commit) {
        return commit && commit.jws !== undefined;
    }
    static isSignedCommit(commit) {
        return commit && commit.link !== undefined;
    }
    static isAnchorCommit(commit) {
        return commit && commit.proof !== undefined;
    }
    static isSignedCommitData(commitData) {
        return commitData && commitData.envelope !== undefined;
    }
    static isAnchorCommitData(commitData) {
        return commitData && commitData.proof !== undefined;
    }
}
exports.StreamUtils = StreamUtils;
//# sourceMappingURL=stream-utils.js.map