import * as u8a from 'uint8arrays';
import * as bigintModArith from './bigint-mod-arith.js';
import * as nist_weierstrass_common from './nist_weierstrass_common.js';
export function keyToDidDoc(pubKeyBytes, fingerprint) {
    const did = `did:key:${fingerprint}`;
    const keyId = `${did}#${fingerprint}`;
    const key = pubKeyBytesToXY(pubKeyBytes);
    return {
        id: did,
        verificationMethod: [{
                id: keyId,
                type: 'JsonWebKey2020',
                controller: did,
                publicKeyJwk: {
                    kty: "EC",
                    crv: "P-256",
                    x: key.xm,
                    y: key.ym,
                },
            }],
        authentication: [keyId],
        assertionMethod: [keyId],
        capabilityDelegation: [keyId],
        capabilityInvocation: [keyId],
    };
}
export function ECPointDecompress(comp) {
    if (!nist_weierstrass_common.testUint8Array(comp)) {
        throw new TypeError('input must be a Uint8Array');
    }
    const two = BigInt(2);
    const prime = (two ** 256n) - (two ** 224n) + (two ** 192n) + (two ** 96n) - 1n;
    const b = 41058363725152142129326129780047268409114441015993725554835256314039467401291n;
    const pIdent = (prime + 1n) / 4n;
    const signY = BigInt(comp[0] - 2);
    const x = comp.subarray(1);
    const xBig = BigInt(u8a.toString(x, 'base10'));
    const a = xBig ** 3n - xBig * 3n + b;
    let yBig = bigintModArith.modPow(a, pIdent, prime);
    if (yBig % 2n !== signY) {
        yBig = prime - yBig;
    }
    return {
        x: xBig,
        y: yBig
    };
}
export function pubKeyBytesToXY(pubKeyBytes) {
    if (!nist_weierstrass_common.testUint8Array(pubKeyBytes)) {
        throw new TypeError('input must be a Uint8Array');
    }
    const publicKeyHex = nist_weierstrass_common.pubKeyBytesToHex(pubKeyBytes);
    const bytesCount = publicKeyHex.length / 2;
    if (bytesCount == 64) {
        return nist_weierstrass_common.publicKeyToXY(publicKeyHex);
    }
    if (bytesCount == 65) {
        if (publicKeyHex.slice(0, 2) == '04') {
            const publicKey = publicKeyHex.slice(2);
            return nist_weierstrass_common.publicKeyToXY(publicKey);
        }
    }
    if (bytesCount == 33) {
        if (publicKeyHex.slice(0, 2) == '03' || publicKeyHex.slice(0, 2) == '02') {
            const publicKey = u8a.fromString(publicKeyHex, 'base16');
            const point = ECPointDecompress(publicKey);
            return nist_weierstrass_common.publicKeyIntToXY(point);
        }
    }
    throw new Error('Unexpected pubKeyBytes');
}
//# sourceMappingURL=secp256r1.js.map