"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CeramicClient = exports.DEFAULT_CLIENT_CONFIG = void 0;
const utils_1 = require("./utils");
const document_1 = require("./document");
const common_1 = require("@ceramicnetwork/common");
const stream_tile_1 = require("@ceramicnetwork/stream-tile");
const stream_caip10_link_1 = require("@ceramicnetwork/stream-caip10-link");
const streamid_1 = require("@ceramicnetwork/streamid");
const remote_pin_api_1 = require("./remote-pin-api");
const API_PATH = '/api/v0';
const CERAMIC_HOST = 'http://localhost:7007';
exports.DEFAULT_CLIENT_CONFIG = {
    syncInterval: 5000,
};
const DEFAULT_APPLY_COMMIT_OPTS = { anchor: true, publish: true, sync: common_1.SyncOptions.PREFER_CACHE };
const DEFAULT_CREATE_FROM_GENESIS_OPTS = {
    anchor: true,
    publish: true,
    sync: common_1.SyncOptions.PREFER_CACHE,
};
const DEFAULT_LOAD_OPTS = { sync: common_1.SyncOptions.PREFER_CACHE };
class CeramicClient {
    constructor(apiHost = CERAMIC_HOST, config = {}) {
        this._config = { ...exports.DEFAULT_CLIENT_CONFIG, ...config };
        this._apiUrl = utils_1.combineURLs(apiHost, API_PATH);
        this._streamCache = new Map();
        this.context = { api: this };
        this.pin = new remote_pin_api_1.RemotePinApi(this._apiUrl);
        this._streamConstructors = {
            [stream_tile_1.TileDocument.STREAM_TYPE_ID]: stream_tile_1.TileDocument,
            [stream_caip10_link_1.Caip10Link.STREAM_TYPE_ID]: stream_caip10_link_1.Caip10Link,
        };
    }
    get did() {
        return this.context.did;
    }
    set did(did) {
        this.context.did = did;
    }
    async createStreamFromGenesis(type, genesis, opts = {}) {
        opts = { ...DEFAULT_CREATE_FROM_GENESIS_OPTS, ...opts };
        const stream = await document_1.Document.createFromGenesis(this._apiUrl, type, genesis, opts, this._config.syncInterval);
        const found = this._streamCache.get(stream.id.toString());
        if (found) {
            if (!common_1.StreamUtils.statesEqual(stream.state, found.state))
                found.next(stream.state);
            return this.buildStream(found);
        }
        else {
            this._streamCache.set(stream.id.toString(), stream);
            return this.buildStream(stream);
        }
    }
    async loadStream(streamId, opts = {}) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts };
        const streamRef = streamid_1.StreamRef.from(streamId);
        let stream = this._streamCache.get(streamRef.baseID.toString());
        if (stream) {
            await stream._syncState(streamRef, opts);
        }
        else {
            stream = await document_1.Document.load(streamRef, this._apiUrl, this._config.syncInterval, opts);
            this._streamCache.set(stream.id.toString(), stream);
        }
        return this.buildStream(stream);
    }
    async multiQuery(queries) {
        const queriesJSON = queries.map((q) => {
            return {
                streamId: typeof q.streamId === 'string' ? q.streamId : q.streamId.toString(),
                paths: q.paths,
                atTime: q.atTime,
            };
        });
        const results = await common_1.fetchJson(this._apiUrl + '/multiqueries', {
            method: 'post',
            body: {
                queries: queriesJSON,
            },
        });
        return Object.entries(results).reduce((acc, e) => {
            const [k, v] = e;
            const state = common_1.StreamUtils.deserializeState(v);
            const stream = new document_1.Document(state, this._apiUrl, this._config.syncInterval);
            acc[k] = this.buildStream(stream);
            return acc;
        }, {});
    }
    loadStreamCommits(streamId) {
        const effectiveStreamId = utils_1.typeStreamID(streamId);
        return document_1.Document.loadStreamCommits(effectiveStreamId, this._apiUrl);
    }
    async applyCommit(streamId, commit, opts = {}) {
        opts = { ...DEFAULT_APPLY_COMMIT_OPTS, ...opts };
        const effectiveStreamId = utils_1.typeStreamID(streamId);
        const document = await document_1.Document.applyCommit(this._apiUrl, effectiveStreamId, commit, opts, this._config.syncInterval);
        const fromCache = this._streamCache.get(effectiveStreamId.toString());
        if (fromCache) {
            fromCache.next(document.state);
            return this.buildStream(document);
        }
        else {
            this._streamCache.set(effectiveStreamId.toString(), document);
            return this.buildStream(document);
        }
    }
    async requestAnchor(streamId, opts = {}) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts };
        const { anchorStatus } = await common_1.fetchJson(`${this._apiUrl}/streams/${streamId.toString()}/anchor`, {
            method: 'post',
            body: {
                opts,
            },
        });
        return anchorStatus;
    }
    addStreamHandler(streamHandler) {
        this._streamConstructors[streamHandler.name] = streamHandler.stream_constructor;
    }
    findStreamConstructor(type) {
        const constructor = this._streamConstructors[type];
        if (constructor) {
            return constructor;
        }
        else {
            throw new Error(`Failed to find constructor for stream ${type}`);
        }
    }
    buildStream(stream) {
        const streamConstructor = this.findStreamConstructor(stream.state.type);
        return new streamConstructor(stream, this.context);
    }
    async setDID(did) {
        this.context.did = did;
    }
    async getSupportedChains() {
        if (this._supportedChains) {
            return this._supportedChains;
        }
        const { supportedChains } = await common_1.fetchJson(this._apiUrl + '/node/chains');
        this._supportedChains = supportedChains;
        return supportedChains;
    }
    async close() {
        Array.from(this._streamCache).map(([, stream]) => {
            stream.complete();
        });
        this._streamCache.clear();
    }
}
exports.CeramicClient = CeramicClient;
exports.default = CeramicClient;
//# sourceMappingURL=ceramic-http-client.js.map