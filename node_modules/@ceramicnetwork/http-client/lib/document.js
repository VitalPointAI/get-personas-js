"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Document = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("@ceramicnetwork/common");
const streamid_1 = require("@ceramicnetwork/streamid");
const query_string_1 = __importDefault(require("query-string"));
class Document extends rxjs_1.Observable {
    constructor(initial, _apiUrl, syncInterval) {
        super((subscriber) => {
            const isFirstObserver = this.state$.observers.length === 0;
            if (isFirstObserver) {
                this.periodicSubscription = rxjs_1.timer(0, syncInterval)
                    .pipe(operators_1.throttle(() => this._syncState(this.id, { sync: common_1.SyncOptions.PREFER_CACHE })))
                    .subscribe();
            }
            this.state$.subscribe(subscriber).add(() => {
                var _a;
                const isNoObserversLeft = this.state$.observers.length === 0;
                if (isNoObserversLeft) {
                    (_a = this.periodicSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                }
            });
        });
        this._apiUrl = _apiUrl;
        this.state$ = new common_1.StreamStateSubject(initial);
    }
    get value() {
        return this.state$.value;
    }
    get state() {
        return this.state$.value;
    }
    next(state) {
        this.state$.next(state);
    }
    async _syncState(streamId, opts) {
        const state = await Document._load(streamId, this._apiUrl, opts);
        this.state$.next(common_1.StreamUtils.deserializeState(state));
    }
    get id() {
        return new streamid_1.StreamID(this.state$.value.type, this.state$.value.log[0].cid);
    }
    static async createFromGenesis(apiUrl, type, genesis, opts, syncInterval) {
        const { state } = await common_1.fetchJson(apiUrl + '/streams', {
            method: 'post',
            body: {
                type,
                genesis: common_1.StreamUtils.serializeCommit(genesis),
                opts,
            },
        });
        return new Document(common_1.StreamUtils.deserializeState(state), apiUrl, syncInterval);
    }
    static async applyCommit(apiUrl, streamId, commit, opts, syncInterval) {
        const { state } = await common_1.fetchJson(apiUrl + '/commits', {
            method: 'post',
            body: {
                streamId: streamId.toString(),
                commit: common_1.StreamUtils.serializeCommit(commit),
                opts,
            },
        });
        return new Document(common_1.StreamUtils.deserializeState(state), apiUrl, syncInterval);
    }
    static async _load(streamId, apiUrl, opts) {
        const url = apiUrl + '/streams/' + streamId.toString() + '?' + query_string_1.default.stringify(opts);
        const { state } = await common_1.fetchJson(url);
        return state;
    }
    static async load(streamId, apiUrl, syncInterval, opts) {
        const state = await Document._load(streamId, apiUrl, opts);
        return new Document(common_1.StreamUtils.deserializeState(state), apiUrl, syncInterval);
    }
    static async loadStreamCommits(streamId, apiUrl) {
        const { commits } = await common_1.fetchJson(`${apiUrl}/commits/${streamId}`);
        return commits.map((r) => {
            return {
                cid: r.cid,
                value: common_1.StreamUtils.deserializeCommit(r.value),
            };
        });
    }
    complete() {
        this.state$.complete();
    }
}
exports.Document = Document;
//# sourceMappingURL=document.js.map